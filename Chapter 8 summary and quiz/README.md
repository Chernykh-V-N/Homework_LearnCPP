Задание №2
Напишите класс Average, который будет вычислять среднее значение всех передаваемых ему целых чисел. Используйте два члена: первый должен быть типа int32_t и использоваться для вычисления суммы всех передаваемых чисел, второй должен быть типа int8_t и использоваться для вычисления количества передаваемых чисел. Чтобы найти среднее значение, нужно разделить сумму на количество.

a) Следующий код функции main():

int main()
{
	Average avg;
	
	avg += 5;
	std::cout << avg << '\n'; // 5 / 1 = 5
	
	avg += 9;
	std::cout << avg << '\n'; // (5 + 9) / 2 = 7
 
	avg += 19;
	std::cout << avg << '\n'; // (5 + 9 + 19) / 3 = 11
 
	avg += -9;
	std::cout << avg << '\n'; // (5 + 9 + 19 - 9) / 4 = 6
 
	(avg += 7) += 11; // выполнение цепочки операций
	std::cout << avg << '\n'; // (5 + 9 + 19 - 9 + 7 + 11) / 6 = 7
 
	Average copy = avg;
	std::cout << copy << '\n';
 
	return 0;
}
Должен выдавать следующий результат:

5
7
11
6
7
7

Ответ №2.а)

b) Требуется ли этому классу явный конструктор копирования или оператор присваивания?

Ответ №2.b)


Задание №3
Напишите свой собственный класс-массив целых чисел IntArray (не используйте std::array или std::vector). Пользователи должны передавать размер массива при создании объекта этого класса, а сам массив (переменная-член) должен выделяться динамически. Используйте стейтменты assert для проверки передаваемых значений, а также свой конструктор копирования и перегрузку оператора присваивания, если это необходимо, чтобы следующий код:

#include <iostream>
 
IntArray fillArray()
{
	IntArray a(6);
	a[0] = 6;
	a[1] = 7;
	a[2] = 3;
	a[3] = 4;
	a[4] = 5;
        a[5] = 8;
 
	return a;
}
 
int main()
{
	IntArray a = fillArray();
	std::cout << a << '\n';
 
	IntArray b(1);
	a = a;
	b = a;
 
	std::cout << b << '\n';
 
	return 0;
}
Выдавал следующий результат:

6 7 3 4 5 8
6 7 3 4 5 8

Ответ №3


Задание №4
Значение типа с плавающей точкой — это число с десятичной дробью, где количество цифр после точки (дробная часть) может меняться. Значение типа с фиксированной точкой — это число с дробью, где дробь (после точки) фиксированная.

Вам нужно написать класс для реализации значений типа с фиксированной точкой с двумя цифрами после точки (например, 11.47, 5.00 или 1465.78). Диапазон класса должен быть от -32768.99 до 32767.99, в дробной части могут быть любые две цифры, не допускайте проблем с точностью.


a) Какого типа данных переменную-член следует использовать для реализации значений типа с фиксированной точкой с 2-мя цифрами после точки? (Обязательно прочитайте ответ, прежде чем приступать к выполнению следующего задания)

Ответ №4.а)

b) Напишите класс FixedPoint, который реализует рекомендуемое решение из предыдущего задания. Если дробная или целая части значения являются отрицательными, то число должно рассматриваться, как отрицательное. Реализуйте перегрузку необходимых операторов и напишите необходимые конструкторы, чтобы следующий код функции main():

int main()
{
	FixedPoint a(37, 58);
	std::cout << a << '\n';
 
	FixedPoint b(-3, 9);
	std::cout << b << '\n';
 
	FixedPoint c(4, -7);
	std::cout << c << '\n';
 
	FixedPoint d(-5, -7);
	std::cout << d << '\n';
 
	FixedPoint e(0, -3);
	std::cout << e << '\n';
 
	std::cout << static_cast<double>(e) << '\n';
 
	return 0;
}
Выдавал следующий результат:

37.58
-3.09
-4.07
-5.07
-0.03
-0.03

Подсказка: Для вывода значения конвертируйте его в тип double, используя оператор static_cast.

Ответ №4.b)

c) Теперь добавьте конструктор, который будет принимать значение типа double. Вы можете округлить целую часть (слева от точки) с помощью функции round() (которая находится в заголовочном файле cmath).

Подсказки:

   Вы можете получить целую часть от числа типа double путем конвертации числа типа double в число типа int.

   Для перемещения одной цифры влево от точки используйте умножение на 10. Для перемещения двух цифр используйте умножение на 100.

Следующий код функции main():

int main()
{
	FixedPoint a(0.03);
	std::cout << a << '\n';
 
	FixedPoint b(-0.03);
	std::cout << b << '\n';
 
	FixedPoint c(4.01); // сохранится, как 4.0099999..., поэтому нам нужно это всё округлить
	std::cout << c << '\n';
 
	FixedPoint d(-4.01); // сохранится, как -4.0099999..., поэтому нам нужно это всё округлить
	std::cout << d << '\n';
 
	return 0;
}
Должен выдавать следующий результат:

0.03
-0.03
4.01
-4.01

Ответ №4.c)

d) Выполните перегрузку следующих операторов: ==, >>, − (унарный) и + (бинарный).

Следующая программа:

void SomeTest()
{
	std::cout << std::boolalpha;
	std::cout << (FixedPoint(0.75) + FixedPoint(1.23) == FixedPoint(1.98)) << '\n'; // оба значения положительные, никакого переполнения
	std::cout << (FixedPoint(0.75) + FixedPoint(1.50) == FixedPoint(2.25)) << '\n'; // оба значения положительные, переполнение
	std::cout << (FixedPoint(-0.75) + FixedPoint(-1.23) == FixedPoint(-1.98)) << '\n'; // оба значения отрицательные, никакого переполнения
	std::cout << (FixedPoint(-0.75) + FixedPoint(-1.50) == FixedPoint(-2.25)) << '\n'; // оба значения отрицательные, переполнение
	std::cout << (FixedPoint(0.75) + FixedPoint(-1.23) == FixedPoint(-0.48)) << '\n'; // второе значение отрицательное, никакого переполнения
	std::cout << (FixedPoint(0.75) + FixedPoint(-1.50) == FixedPoint(-0.75)) << '\n'; // второе значение отрицательное, возможно переполнение
	std::cout << (FixedPoint(-0.75) + FixedPoint(1.23) == FixedPoint(0.48)) << '\n'; // первое значение отрицательное, никакого переполнения
	std::cout << (FixedPoint(-0.75) + FixedPoint(1.50) == FixedPoint(0.75)) << '\n'; // первое значение отрицательное, возможно переполнение
}
 
int main()
{
	SomeTest();
 
	FixedPoint a(-0.48); 
	std::cout << a << '\n';
 
	std::cout << -a << '\n';
 
	std::cout << "Enter a number: "; // введите 5.678
	std::cin >> a;
	
	std::cout << "You entered: " << a << '\n';
 
	return 0;
}
Должна выдавать следующий результат:

true
true
true
true
true
true
true
true
-0.48
0.48
Enter a number: 5.678
You entered: 5.68

Подсказка: Для выполнения перегрузки оператора >> используйте конструктор с параметром типа double для создания анонимного объекта класса FixedPoint, а затем присвойте этот объект параметру функции перегрузки оператора >>.

Ответ №4.d)
